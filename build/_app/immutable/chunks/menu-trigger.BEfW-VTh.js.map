{"version":3,"file":"menu-trigger.BEfW-VTh.js","sources":["../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/array.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js","../../../../../../node_modules/nanoid/non-secure/index.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/id.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/debounce.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/rovingFocus.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/typeahead.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/focus.js","../../../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js","../../../../../../node_modules/tabbable/dist/index.esm.js","../../../../../../node_modules/focus-trap/dist/focus-trap.esm.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/modal/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/portal.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/interact-outside/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/menu/create.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/dropdown-menu/create.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/separator/create.js","../../../../../../node_modules/bits-ui/dist/bits/floating/helpers.js","../../../../../../node_modules/bits-ui/dist/bits/menu/ctx.js","../../../../../../node_modules/bits-ui/dist/bits/menu/components/menu.svelte","../../../../../../node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte","../../../../../../node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte"],"sourcesContent":["import { dequal as deepEqual } from 'dequal';\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first element will be returned.\n *   - If looping is enabled, the last element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function back(array, index, increment, loop = true) {\n    const previousIndex = index - increment;\n    if (previousIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[previousIndex];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the last element will be returned.\n *   - If looping is enabled, the first element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    const nextIndex = index + increment;\n    if (nextIndex > array.length - 1) {\n        return loop ? array[0] : array[array.length - 1];\n    }\n    return array[nextIndex];\n}\n/**\n * Returns the array element after to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (index === array.length - 1) {\n        return loop ? array[0] : array[index];\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, currentIndex, loop = true) {\n    if (currentIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[currentIndex - 1];\n}\n/**\n * Returns the last element in an array.\n * @param array the array.\n */\nexport function last(array) {\n    return array[array.length - 1];\n}\n/**\n * Wraps an array around itself at a given starting index.\n * @example ```ts\n * wrapArray(['a', 'b', 'c', 'd'], 2);\n * // ['c', 'd', 'a', 'b']\n * ```\n * @see https://github.com/radix-ui/primitives\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n/**\n * Toggles an item in an array. If the item is already in the array,\n * it is removed. Otherwise, it is added.\n * @param item The item to toggle.\n * @param array The array to toggle the item in.\n * @returns The updated array with the item toggled.\n * @template T The type of the items in the array.\n * @example ```typescript\n * const arr = [1, 2, 3];\n * const newArr = toggle(2, arr);\n * // newArr = [1, 3]\n * ```\n */\nexport function toggle(item, array, compare = deepEqual) {\n    const itemIdx = array.findIndex((innerItem) => compare(innerItem, item));\n    if (itemIdx !== -1) {\n        array.splice(itemIdx, 1);\n    }\n    else {\n        array.push(item);\n    }\n    return array;\n}\n/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk(arr, size) {\n    const result = [];\n    for (let i = 0; i < arr.length; i += size) {\n        result.push(arr.slice(i, i + size));\n    }\n    return result;\n}\n/**\n * Checks if the given index is valid for the given array.\n *\n * @param index - The index to check\n * @param arr - The array to check\n */\nexport function isValidIndex(index, arr) {\n    return index >= 0 && index < arr.length;\n}\n","export function addHighlight(element) {\n    element.setAttribute('data-highlighted', '');\n}\nexport function removeHighlight(element) {\n    element.removeAttribute('data-highlighted');\n}\n","export function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { nanoid } from 'nanoid/non-secure';\n/**\n * A function that generates a random id\n * @returns An id\n */\nexport function generateId() {\n    return nanoid(10);\n}\nexport function generateIds(args) {\n    return args.reduce((acc, curr) => {\n        acc[curr] = generateId();\n        return acc;\n    }, {});\n}\nexport function stringifiedIdObjType(args) {\n    return `Record<${args.map((arg) => `\"${arg}\"`).join(' | ')}, string>`;\n}\n","export function debounce(fn, wait = 500) {\n    let timeout = null;\n    return function (...args) {\n        const later = () => {\n            timeout = null;\n            fn(...args);\n        };\n        timeout && clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n","export const isDom = () => typeof window !== 'undefined';\nexport function getPlatform() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const agent = navigator.userAgentData;\n    return (agent?.platform ?? navigator.platform);\n}\nconst pt = (v) => isDom() && v.test(getPlatform().toLowerCase());\nconst ua = (v) => isDom() && v.test(navigator.userAgent);\nconst vn = (v) => isDom() && v.test(navigator.vendor);\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nexport const isMac = () => pt(/^mac/) && !isTouchDevice();\nexport const isIPhone = () => pt(/^iphone/);\nexport const isSafari = () => isApple() && vn(/apple/i);\nexport const isFirefox = () => ua(/firefox\\//i);\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i);\nexport const isIos = () => isApple() && !isMac();\n","// Modified from @zag-js/remove-scroll v0.10.2 (2023-06-10)\n// Source: https://github.com/chakra-ui/zag\n// https://github.com/chakra-ui/zag/blob/main/packages/utilities/remove-scroll/src/index.ts\nimport { noop } from './callbacks.js';\nimport { isIos } from './platform.js';\nconst LOCK_CLASSNAME = 'data-melt-scroll-lock';\nfunction assignStyle(el, style) {\n    if (!el)\n        return;\n    const previousStyle = el.style.cssText;\n    Object.assign(el.style, style);\n    return () => {\n        el.style.cssText = previousStyle;\n    };\n}\nfunction setCSSProperty(el, property, value) {\n    if (!el)\n        return;\n    const previousValue = el.style.getPropertyValue(property);\n    el.style.setProperty(property, value);\n    return () => {\n        if (previousValue) {\n            el.style.setProperty(property, previousValue);\n        }\n        else {\n            el.style.removeProperty(property);\n        }\n    };\n}\nfunction getPaddingProperty(documentElement) {\n    // RTL <body> scrollbar\n    const documentLeft = documentElement.getBoundingClientRect().left;\n    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;\n    return scrollbarX ? 'paddingLeft' : 'paddingRight';\n}\nexport function removeScroll(_document) {\n    const doc = _document ?? document;\n    const win = doc.defaultView ?? window;\n    const { documentElement, body } = doc;\n    const locked = body.hasAttribute(LOCK_CLASSNAME);\n    if (locked)\n        return noop;\n    body.setAttribute(LOCK_CLASSNAME, '');\n    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;\n    const setScrollbarWidthProperty = () => setCSSProperty(documentElement, '--scrollbar-width', `${scrollbarWidth}px`);\n    const paddingProperty = getPaddingProperty(documentElement);\n    const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];\n    const setStyle = () => assignStyle(body, {\n        overflow: 'hidden',\n        [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n    });\n    // Only iOS doesn't respect `overflow: hidden` on document.body\n    const setIOSStyle = () => {\n        const { scrollX, scrollY, visualViewport } = win;\n        // iOS 12 does not support `visuaViewport`.\n        const offsetLeft = visualViewport?.offsetLeft ?? 0;\n        const offsetTop = visualViewport?.offsetTop ?? 0;\n        const restoreStyle = assignStyle(body, {\n            position: 'fixed',\n            overflow: 'hidden',\n            top: `${-(scrollY - Math.floor(offsetTop))}px`,\n            left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n            right: '0',\n            [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n        });\n        return () => {\n            restoreStyle?.();\n            win.scrollTo(scrollX, scrollY);\n        };\n    };\n    const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];\n    return () => {\n        cleanups.forEach((fn) => fn?.());\n        body.removeAttribute(LOCK_CLASSNAME);\n    };\n}\n","import { derived } from 'svelte/store';\n/**\n * Helper function to standardize the way we derive a visible state for the\n * popper/floating elements.\n */\nexport function derivedVisible(obj) {\n    const { open, forceVisible, activeTrigger } = obj;\n    return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);\n}\n","import { isBrowser, isHTMLElement } from './is.js';\nimport { sleep } from './sleep.js';\n/**\n * Manage roving focus between elements. Sets the current active element to\n * tabindex -1 and the next element to tabindex 0.\n *\n * @param nextElement The element to focus on\n */\nexport function handleRovingFocus(nextElement) {\n    if (!isBrowser)\n        return;\n    sleep(1).then(() => {\n        const currentFocusedElement = document.activeElement;\n        if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)\n            return;\n        currentFocusedElement.tabIndex = -1;\n        if (nextElement) {\n            nextElement.tabIndex = 0;\n            nextElement.focus();\n        }\n    });\n}\nfunction getFocusableElements() {\n    return Array.from(document.querySelectorAll('a[href]:not([tabindex=\"-1\"]), button:not([disabled]):not([tabindex=\"-1\"]), input:not([disabled]):not([tabindex=\"-1\"]), select:not([disabled]):not([tabindex=\"-1\"]), textarea:not([disabled]):not([tabindex=\"-1\"]), [tabindex]:not([tabindex=\"-1\"])'));\n}\nexport function getNextFocusable(currentElement) {\n    const focusableElements = getFocusableElements();\n    const currentIndex = focusableElements.indexOf(currentElement);\n    const nextIndex = currentIndex + 1;\n    const nextElement = focusableElements[nextIndex];\n    if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {\n        return nextElement;\n    }\n    return null;\n}\nexport function getPreviousFocusable(currentElement) {\n    const focusableElements = getFocusableElements();\n    const currentIndex = focusableElements.indexOf(currentElement);\n    const previousIndex = currentIndex - 1;\n    const prevElement = focusableElements[previousIndex];\n    if (previousIndex >= 0 && isHTMLElement(prevElement)) {\n        return prevElement;\n    }\n    return null;\n}\n","import { get, writable } from 'svelte/store';\nimport { wrapArray } from './array.js';\nimport { debounce } from './debounce.js';\nimport { isHTMLElement } from './is.js';\nimport { handleRovingFocus } from './rovingFocus.js';\nimport { withGet } from './withGet.js';\n/**\n * Keys to ignore for typeahead so we aren't matching things\n * like `Shift menu item` or `Control center` or `Alt menu` when\n * a user presses those keys.\n */\nconst ignoredKeys = new Set(['Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'NumLock']);\n/**\n * Default options for the typeahead search.\n * We default to roving focus when a match is found, but\n * you can override this with the `onMatch` option.\n */\nconst defaults = {\n    onMatch: handleRovingFocus,\n    getCurrentItem: () => document.activeElement,\n};\nexport function createTypeaheadSearch(args = {}) {\n    const withDefaults = { ...defaults, ...args };\n    const typed = withGet(writable([]));\n    const resetTyped = debounce(() => {\n        typed.update(() => []);\n    });\n    const handleTypeaheadSearch = (key, items) => {\n        if (ignoredKeys.has(key))\n            return;\n        const currentItem = withDefaults.getCurrentItem();\n        const $typed = get(typed);\n        if (!Array.isArray($typed)) {\n            return;\n        }\n        $typed.push(key.toLowerCase());\n        typed.set($typed);\n        const candidateItems = items.filter((item) => {\n            if (item.getAttribute('disabled') === 'true' ||\n                item.getAttribute('aria-disabled') === 'true' ||\n                item.hasAttribute('data-disabled')) {\n                return false;\n            }\n            return true;\n        });\n        const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);\n        const normalizeSearch = isRepeated ? $typed[0] : $typed.join('');\n        const currentItemIndex = isHTMLElement(currentItem) ? candidateItems.indexOf(currentItem) : -1;\n        let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));\n        const excludeCurrentItem = normalizeSearch.length === 1;\n        if (excludeCurrentItem) {\n            wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n        }\n        const nextItem = wrappedItems.find((item) => item?.innerText && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));\n        if (isHTMLElement(nextItem) && nextItem !== currentItem) {\n            withDefaults.onMatch(nextItem);\n        }\n        resetTyped();\n    };\n    return {\n        typed,\n        resetTyped,\n        handleTypeaheadSearch,\n    };\n}\n","import { isHTMLElement } from './is.js';\n/**\n * Get an element's ancestor which has a `data-portal` attribute.\n * This is used to handle nested portals/overlays/dialogs/popovers.\n */\nfunction getPortalParent(node) {\n    let parent = node.parentElement;\n    while (isHTMLElement(parent) && !parent.hasAttribute('data-portal')) {\n        parent = parent.parentElement;\n    }\n    return parent || 'body';\n}\n/**\n * Gets the destination for a portal given the node and a user-specified portal prop.\n * If a portal prop is not `undefined`, it is used as the destination.\n */\nexport function getPortalDestination(node, portalProp) {\n    // user-specified portal prop, use it\n    if (portalProp !== undefined)\n        return portalProp;\n    // find the closest portal parent, or the body if none is found\n    const portalParent = getPortalParent(node);\n    // if the portalParent is the body, we portal to the body\n    // making it a \"top-level\" portal\n    if (portalParent === 'body')\n        return document.body;\n    // if the portalParent is not the body, we have a portal parent\n    // and shouldn't portal to anything so it remains within that parent\n    // so we return `null`\n    return null;\n}\n","import { isFunction, isHTMLElement, sleep } from './index.js';\nimport { tick } from 'svelte';\nexport async function handleFocus(args) {\n    const { prop, defaultEl } = args;\n    await Promise.all([sleep(1), tick]);\n    if (prop === undefined) {\n        defaultEl?.focus();\n        return;\n    }\n    const returned = isFunction(prop) ? prop(defaultEl) : prop;\n    if (typeof returned === 'string') {\n        // Get el by selector, focus it\n        const el = document.querySelector(returned);\n        if (!isHTMLElement(el))\n            return;\n        el.focus();\n    }\n    else if (isHTMLElement(returned)) {\n        // Focus it\n        returned.focus();\n    }\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/floating/placement.ts\nimport { flip, offset, arrow, shift, size, computePosition, autoUpdate, } from '@floating-ui/dom';\nimport { isHTMLElement, noop } from '../../helpers/index.js';\nconst defaultConfig = {\n    strategy: 'absolute',\n    placement: 'top',\n    gutter: 5,\n    flip: true,\n    sameWidth: false,\n    overflowPadding: 8,\n};\nconst ARROW_TRANSFORM = {\n    bottom: 'rotate(45deg)',\n    left: 'rotate(135deg)',\n    top: 'rotate(225deg)',\n    right: 'rotate(315deg)',\n};\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'];\nconst ALIGN_OPTIONS = ['start', 'center', 'end'];\nexport function useFloating(reference, floating, opts = {}) {\n    if (!floating || !reference || opts === null)\n        return {\n            destroy: noop,\n        };\n    const options = { ...defaultConfig, ...opts };\n    const arrowEl = floating.querySelector('[data-arrow=true]');\n    const middleware = [];\n    if (options.flip) {\n        middleware.push(flip({\n            boundary: options.boundary,\n            padding: options.overflowPadding,\n        }));\n    }\n    const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;\n    if (options.gutter || options.offset) {\n        const data = options.gutter ? { mainAxis: options.gutter } : options.offset;\n        if (data?.mainAxis != null) {\n            data.mainAxis += arrowOffset;\n        }\n        middleware.push(offset(data));\n    }\n    middleware.push(shift({\n        boundary: options.boundary,\n        crossAxis: options.overlap,\n        padding: options.overflowPadding,\n    }));\n    if (arrowEl) {\n        middleware.push(arrow({ element: arrowEl, padding: 8 }));\n    }\n    middleware.push(size({\n        padding: options.overflowPadding,\n        apply({ rects, availableHeight, availableWidth }) {\n            if (options.sameWidth) {\n                Object.assign(floating.style, {\n                    width: `${Math.round(rects.reference.width)}px`,\n                    minWidth: 'unset',\n                });\n            }\n            if (options.fitViewport) {\n                Object.assign(floating.style, {\n                    maxWidth: `${availableWidth}px`,\n                    maxHeight: `${availableHeight}px`,\n                });\n            }\n        },\n    }));\n    function compute() {\n        if (!reference || !floating)\n            return;\n        // if the reference is no longer in the document (e.g. it was removed), ignore it\n        if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))\n            return;\n        const { placement, strategy } = options;\n        computePosition(reference, floating, {\n            placement,\n            middleware,\n            strategy,\n        }).then((data) => {\n            const x = Math.round(data.x);\n            const y = Math.round(data.y);\n            // get the chosen side and align from the placement to apply as attributes\n            // to the floating element and arrow\n            const [side, align] = getSideAndAlignFromPlacement(data.placement);\n            floating.setAttribute('data-side', side);\n            floating.setAttribute('data-align', align);\n            Object.assign(floating.style, {\n                position: options.strategy,\n                top: `${y}px`,\n                left: `${x}px`,\n            });\n            if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {\n                const { x, y } = data.middlewareData.arrow;\n                const dir = data.placement.split('-')[0];\n                arrowEl.setAttribute('data-side', dir);\n                Object.assign(arrowEl.style, {\n                    position: 'absolute',\n                    left: x != null ? `${x}px` : '',\n                    top: y != null ? `${y}px` : '',\n                    [dir]: `calc(100% - ${arrowOffset}px)`,\n                    transform: ARROW_TRANSFORM[dir],\n                    backgroundColor: 'inherit',\n                    zIndex: 'inherit',\n                });\n            }\n            return data;\n        });\n    }\n    // Apply `position` to floating element prior to the computePosition() call.\n    Object.assign(floating.style, {\n        position: options.strategy,\n    });\n    return {\n        destroy: autoUpdate(reference, floating, compute),\n    };\n}\nfunction getSideAndAlignFromPlacement(placement) {\n    const [side, align = 'center'] = placement.split('-');\n    return [side, align];\n}\n","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.5.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { isFocusable, tabbable, focusable, isTabbable, getTabIndex } from 'tabbable';\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        tryFocus(nextNode);\n      } else {\n        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  var checkKey = function checkKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/focusTrap/focusTrap.ts\nimport { writable, readonly } from 'svelte/store';\nimport { createFocusTrap as _createFocusTrap } from 'focus-trap';\nexport function createFocusTrap(config = {}) {\n    let trap;\n    const { immediate, ...focusTrapOptions } = config;\n    const hasFocus = writable(false);\n    const isPaused = writable(false);\n    const activate = (opts) => trap?.activate(opts);\n    const deactivate = (opts) => {\n        trap?.deactivate(opts);\n    };\n    const pause = () => {\n        if (trap) {\n            trap.pause();\n            isPaused.set(true);\n        }\n    };\n    const unpause = () => {\n        if (trap) {\n            trap.unpause();\n            isPaused.set(false);\n        }\n    };\n    const useFocusTrap = (node) => {\n        trap = _createFocusTrap(node, {\n            ...focusTrapOptions,\n            onActivate() {\n                hasFocus.set(true);\n                config.onActivate?.();\n            },\n            onDeactivate() {\n                hasFocus.set(false);\n                config.onDeactivate?.();\n            },\n        });\n        if (immediate) {\n            activate();\n        }\n        return {\n            destroy() {\n                deactivate();\n                trap = undefined;\n            },\n        };\n    };\n    return {\n        useFocusTrap,\n        hasFocus: readonly(hasFocus),\n        isPaused: readonly(isPaused),\n        activate,\n        deactivate,\n        pause,\n        unpause,\n    };\n}\n","import { isElement, last, noop, sleep } from '../../helpers/index.js';\nimport { useInteractOutside } from '../index.js';\nconst visibleModals = [];\nexport function useModal(node, config) {\n    let unsubInteractOutside = noop;\n    function removeNodeFromVisibleModals() {\n        const index = visibleModals.indexOf(node);\n        if (index >= 0) {\n            visibleModals.splice(index, 1);\n        }\n    }\n    function update(config) {\n        unsubInteractOutside();\n        const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config;\n        sleep(100).then(() => {\n            if (open) {\n                visibleModals.push(node);\n            }\n            else {\n                removeNodeFromVisibleModals();\n            }\n        });\n        function isLastModal() {\n            return last(visibleModals) === node;\n        }\n        function closeModal() {\n            // we only want to call onClose if this is the topmost modal\n            if (isLastModal() && onClose) {\n                onClose();\n                removeNodeFromVisibleModals();\n            }\n        }\n        function onInteractOutsideStart(e) {\n            const target = e.target;\n            if (!isElement(target))\n                return;\n            if (target && isLastModal()) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n        function onInteractOutside(e) {\n            if (shouldCloseOnInteractOutside?.(e) && isLastModal()) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n                closeModal();\n            }\n        }\n        unsubInteractOutside = useInteractOutside(node, {\n            onInteractOutsideStart,\n            onInteractOutside: closeOnInteractOutside ? onInteractOutside : undefined,\n            enabled: open,\n        }).destroy;\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            removeNodeFromVisibleModals();\n            unsubInteractOutside();\n        },\n    };\n}\n","import { createFocusTrap, useEscapeKeydown, useFloating, usePortal, } from '../index.js';\nimport { executeCallbacks, noop, isHTMLElement, } from '../../helpers/index.js';\nimport { useModal } from '../modal/action.js';\nconst defaultConfig = {\n    floating: {},\n    focusTrap: {},\n    modal: {},\n    escapeKeydown: {},\n    portal: 'body',\n};\nexport const usePopper = (popperElement, args) => {\n    popperElement.dataset.escapee = '';\n    const { anchorElement, open, options } = args;\n    if (!anchorElement || !open || !options) {\n        return { destroy: noop };\n    }\n    const opts = { ...defaultConfig, ...options };\n    const callbacks = [];\n    if (opts.portal !== null) {\n        const portal = usePortal(popperElement, opts.portal);\n        if (portal?.destroy) {\n            callbacks.push(portal.destroy);\n        }\n    }\n    callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);\n    if (opts.focusTrap !== null) {\n        const { useFocusTrap } = createFocusTrap({\n            immediate: true,\n            escapeDeactivates: false,\n            allowOutsideClick: true,\n            returnFocusOnDeactivate: false,\n            fallbackFocus: popperElement,\n            ...opts.focusTrap,\n        });\n        const usedFocusTrap = useFocusTrap(popperElement);\n        if (usedFocusTrap?.destroy) {\n            callbacks.push(usedFocusTrap.destroy);\n        }\n    }\n    if (opts.modal !== null) {\n        callbacks.push(useModal(popperElement, {\n            onClose: () => {\n                if (isHTMLElement(anchorElement)) {\n                    open.set(false);\n                    anchorElement.focus();\n                }\n            },\n            shouldCloseOnInteractOutside: (e) => {\n                if (e.defaultPrevented)\n                    return false;\n                if (isHTMLElement(anchorElement) && anchorElement.contains(e.target)) {\n                    return false;\n                }\n                return true;\n            },\n            ...opts.modal,\n        }).destroy);\n    }\n    if (opts.escapeKeydown !== null) {\n        callbacks.push(useEscapeKeydown(popperElement, {\n            enabled: open,\n            handler: () => {\n                open.set(false);\n            },\n            ...opts.escapeKeydown,\n        }).destroy);\n    }\n    // @ts-expect-error - This works and is correct, but TS doesn't like it\n    const unsubscribe = executeCallbacks(...callbacks);\n    return {\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n","import { tick } from 'svelte';\nimport { isHTMLElement, noop } from '../helpers/index.js';\nexport const usePortal = (el, target = 'body') => {\n    let targetEl;\n    if (!isHTMLElement(target) && typeof target !== 'string') {\n        return {\n            destroy: noop,\n        };\n    }\n    async function update(newTarget) {\n        target = newTarget;\n        if (typeof target === 'string') {\n            targetEl = document.querySelector(target);\n            if (targetEl === null) {\n                await tick();\n                targetEl = document.querySelector(target);\n            }\n            if (targetEl === null) {\n                throw new Error(`No element found matching css selector: \"${target}\"`);\n            }\n        }\n        else if (target instanceof HTMLElement) {\n            targetEl = target;\n        }\n        else {\n            throw new TypeError(`Unknown portal target type: ${target === null ? 'null' : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);\n        }\n        el.dataset.portal = '';\n        targetEl.appendChild(el);\n        el.hidden = false;\n    }\n    function destroy() {\n        el.remove();\n    }\n    update(target);\n    return {\n        update,\n        destroy,\n    };\n};\n","import { addEventListener, isElement, executeCallbacks, noop, } from '../../helpers/index.js';\nexport function useInteractOutside(node, config) {\n    let unsub = noop;\n    let isPointerDown = false;\n    let isPointerDownInside = false;\n    let ignoreEmulatedMouseEvents = false;\n    function update(config) {\n        unsub();\n        const { onInteractOutside, onInteractOutsideStart, enabled } = config;\n        if (!enabled)\n            return;\n        function onPointerDown(e) {\n            if (onInteractOutside && isValidEvent(e, node)) {\n                onInteractOutsideStart?.(e);\n            }\n            const target = e.target;\n            if (isElement(target) && isOrContainsTarget(node, target)) {\n                isPointerDownInside = true;\n            }\n            isPointerDown = true;\n        }\n        function triggerInteractOutside(e) {\n            onInteractOutside?.(e);\n        }\n        const documentObj = getOwnerDocument(node);\n        // Use pointer events if available, otherwise use mouse/touch events\n        if (typeof PointerEvent !== 'undefined') {\n            const onPointerUp = (e) => {\n                if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            unsub = executeCallbacks(addEventListener(documentObj, 'pointerdown', onPointerDown, true), addEventListener(documentObj, 'pointerup', onPointerUp, true));\n        }\n        else {\n            const onMouseUp = (e) => {\n                if (ignoreEmulatedMouseEvents) {\n                    ignoreEmulatedMouseEvents = false;\n                }\n                else if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            const onTouchEnd = (e) => {\n                ignoreEmulatedMouseEvents = true;\n                if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            unsub = executeCallbacks(addEventListener(documentObj, 'mousedown', onPointerDown, true), addEventListener(documentObj, 'mouseup', onMouseUp, true), addEventListener(documentObj, 'touchstart', onPointerDown, true), addEventListener(documentObj, 'touchend', onTouchEnd, true));\n        }\n    }\n    function shouldTriggerInteractOutside(e) {\n        if (isPointerDown && !isPointerDownInside && isValidEvent(e, node)) {\n            return true;\n        }\n        return false;\n    }\n    function resetPointerState() {\n        isPointerDown = false;\n        isPointerDownInside = false;\n    }\n    update(config);\n    return {\n        update,\n        destroy: unsub,\n    };\n}\nfunction isValidEvent(e, node) {\n    if ('button' in e && e.button > 0)\n        return false;\n    const target = e.target;\n    if (!isElement(target))\n        return false;\n    // if the target is no longer in the document (e.g. it was removed) ignore it\n    const ownerDocument = target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {\n        return false;\n    }\n    return node && !isOrContainsTarget(node, target);\n}\nfunction isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\nfunction getOwnerDocument(el) {\n    return el?.ownerDocument ?? document;\n}\n","import { createSeparator } from '../index.js';\nimport { useEscapeKeydown, usePopper, usePortal } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, SELECTION_KEYS, addEventListener, addHighlight, addMeltEventListener, makeElement, createElHelpers, createTypeaheadSearch, derivedVisible, disabledAttr, effect, executeCallbacks, generateIds, getNextFocusable, getPortalDestination, getPreviousFocusable, handleFocus, handleRovingFocus, isBrowser, isElementDisabled, isHTMLElement, kbd, noop, omit, overridable, removeHighlight, removeScroll, sleep, styleToString, toWritableStores, portalAttr, } from '../../internal/helpers/index.js';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nimport { safeOnMount } from '../../internal/helpers/lifecycle.js';\nimport { withGet } from '../../internal/helpers/withGet.js';\nexport const SUB_OPEN_KEYS = {\n    ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],\n    rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT],\n};\nexport const SUB_CLOSE_KEYS = {\n    ltr: [kbd.ARROW_LEFT],\n    rtl: [kbd.ARROW_RIGHT],\n};\nexport const menuIdParts = ['menu', 'trigger'];\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    typeahead: true,\n    closeOnItemClick: true,\n    onOutsideClick: undefined,\n};\nexport function createMenuBuilder(opts) {\n    const { name, selector } = createElHelpers(opts.selector);\n    const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem, closeOnItemClick, onOutsideClick, } = opts.rootOptions;\n    const rootOpen = opts.rootOpen;\n    const rootActiveTrigger = opts.rootActiveTrigger;\n    /**\n     * Keeps track of the next/previous focusable element when the menu closes.\n     * This is because we are portaling the menu to the body and we need\n     * to be able to focus the next element in the DOM when the menu closes.\n     *\n     * Without keeping track of this, the focus would be reset to the top of\n     * the page (or the first focusable element in the body).\n     */\n    const nextFocusable = opts.nextFocusable;\n    const prevFocusable = opts.prevFocusable;\n    /**\n     * Keeps track of if the user is using the keyboard to navigate the menu.\n     * This is used to determine how we handle focus on open behavior differently\n     * than when the user is using the mouse.\n     */\n    const isUsingKeyboard = withGet.writable(false);\n    /**\n     * Stores used to manage the grace area for submenus. This prevents us\n     * from closing a submenu when the user is moving their mouse from the\n     * trigger to the submenu.\n     */\n    const lastPointerX = withGet(writable(0));\n    const pointerGraceIntent = withGet(writable(null));\n    const pointerDir = withGet(writable('right'));\n    /**\n     * Track currently focused item in the menu.\n     */\n    const currentFocusedItem = withGet(writable(null));\n    const pointerMovingToSubmenu = withGet(derived([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {\n        return (e) => {\n            const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;\n            return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent?.area);\n        };\n    }));\n    const { typed, handleTypeaheadSearch } = createTypeaheadSearch();\n    const rootIds = toWritableStores({ ...generateIds(menuIdParts), ...opts.ids });\n    const isVisible = derivedVisible({\n        open: rootOpen,\n        forceVisible,\n        activeTrigger: rootActiveTrigger,\n    });\n    const rootMenu = makeElement(name(), {\n        stores: [isVisible, portal, rootIds.menu, rootIds.trigger],\n        returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {\n            return {\n                role: 'menu',\n                hidden: $isVisible ? undefined : true,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: $rootMenuId,\n                'aria-labelledby': $rootTriggerId,\n                'data-state': $isVisible ? 'open' : 'closed',\n                'data-portal': portalAttr($portal),\n                tabindex: -1,\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape,]) => {\n                unsubPopper();\n                if (!$isVisible || !$rootActiveTrigger)\n                    return;\n                tick().then(() => {\n                    setMeltMenuAttribute(node, selector);\n                    const popper = usePopper(node, {\n                        anchorElement: $rootActiveTrigger,\n                        open: rootOpen,\n                        options: {\n                            floating: $positioning,\n                            modal: {\n                                closeOnInteractOutside: $closeOnOutsideClick,\n                                shouldCloseOnInteractOutside: (e) => {\n                                    onOutsideClick.get()?.(e);\n                                    if (e.defaultPrevented)\n                                        return false;\n                                    if (isHTMLElement($rootActiveTrigger) &&\n                                        $rootActiveTrigger.contains(e.target)) {\n                                        return false;\n                                    }\n                                    return true;\n                                },\n                                onClose: () => {\n                                    rootOpen.set(false);\n                                    $rootActiveTrigger.focus();\n                                },\n                                open: $isVisible,\n                            },\n                            portal: getPortalDestination(node, $portal),\n                            escapeKeydown: $closeOnEscape ? undefined : null,\n                        },\n                    });\n                    if (popper && popper.destroy) {\n                        unsubPopper = popper.destroy;\n                    }\n                });\n            });\n            const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                const target = e.target;\n                const menuEl = e.currentTarget;\n                if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                    return;\n                /**\n                 * Submenu key events bubble through portals and\n                 * we only care about key events that happen inside this menu.\n                 */\n                const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                if (!isKeyDownInside)\n                    return;\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    handleMenuNavigation(e, loop.get() ?? false);\n                }\n                /**\n                 * Menus should not be navigated using tab\n                 * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                 */\n                if (e.key === kbd.TAB) {\n                    e.preventDefault();\n                    rootOpen.set(false);\n                    handleTabNavigation(e, nextFocusable, prevFocusable);\n                    return;\n                }\n                /**\n                 * Check for typeahead search and handle it.\n                 */\n                const isCharacterKey = e.key.length === 1;\n                const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                if (!isModifierKey && isCharacterKey && typeahead.get() === true) {\n                    handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                }\n            }));\n            return {\n                destroy() {\n                    unsubDerived();\n                    unsubEvents();\n                    unsubPopper();\n                },\n            };\n        },\n    });\n    const rootTrigger = makeElement(name('trigger'), {\n        stores: [rootOpen, rootIds.menu, rootIds.trigger],\n        returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {\n            return {\n                'aria-controls': $rootMenuId,\n                'aria-expanded': $rootOpen,\n                'data-state': $rootOpen ? 'open' : 'closed',\n                id: $rootTriggerId,\n                tabindex: 0,\n            };\n        },\n        action: (node) => {\n            applyAttrsIfDisabled(node);\n            rootActiveTrigger.update((p) => {\n                if (p)\n                    return p;\n                return node;\n            });\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                const $rootOpen = rootOpen.get();\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                handleOpen(triggerEl);\n                if (!$rootOpen)\n                    e.preventDefault();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN))\n                    return;\n                e.preventDefault();\n                handleOpen(triggerEl);\n                const menuId = triggerEl.getAttribute('aria-controls');\n                if (!menuId)\n                    return;\n                const menu = document.getElementById(menuId);\n                if (!menu)\n                    return;\n                const menuItems = getMenuItems(menu);\n                if (!menuItems.length)\n                    return;\n                handleRovingFocus(menuItems[0]);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const rootArrow = makeElement(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    const overlay = makeElement(name('overlay'), {\n        stores: [isVisible],\n        returned: ([$isVisible]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                'aria-hidden': 'true',\n                'data-state': stateAttr($isVisible),\n            };\n        },\n        action: (node) => {\n            let unsubEscapeKeydown = noop;\n            if (closeOnEscape.get()) {\n                const escapeKeydown = useEscapeKeydown(node, {\n                    handler: () => {\n                        rootOpen.set(false);\n                        const $rootActiveTrigger = rootActiveTrigger.get();\n                        if ($rootActiveTrigger)\n                            $rootActiveTrigger.focus();\n                    },\n                });\n                if (escapeKeydown && escapeKeydown.destroy) {\n                    unsubEscapeKeydown = escapeKeydown.destroy;\n                }\n            }\n            const unsubPortal = effect([portal], ([$portal]) => {\n                if ($portal === null)\n                    return noop;\n                const portalDestination = getPortalDestination(node, $portal);\n                if (portalDestination === null)\n                    return noop;\n                const portalAction = usePortal(node, portalDestination);\n                if (portalAction && portalAction.destroy) {\n                    return portalAction.destroy;\n                }\n                else {\n                    return noop;\n                }\n            });\n            return {\n                destroy() {\n                    unsubEscapeKeydown();\n                    unsubPortal();\n                },\n            };\n        },\n    });\n    const item = makeElement(name('item'), {\n        returned: () => {\n            return {\n                role: 'menuitem',\n                tabindex: -1,\n                'data-orientation': 'vertical',\n            };\n        },\n        action: (node) => {\n            setMeltMenuAttribute(node, selector);\n            applyAttrsIfDisabled(node);\n            const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (isElementDisabled(itemEl)) {\n                    e.preventDefault();\n                    return;\n                }\n            }), addMeltEventListener(node, 'click', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (isElementDisabled(itemEl)) {\n                    e.preventDefault();\n                    return;\n                }\n                if (e.defaultPrevented) {\n                    handleRovingFocus(itemEl);\n                    return;\n                }\n                if (closeOnItemClick.get()) {\n                    // Allows forms to submit before the menu is removed from the DOM\n                    sleep(1).then(() => {\n                        rootOpen.set(false);\n                    });\n                }\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                onItemKeyDown(e);\n            }), addMeltEventListener(node, 'pointermove', (e) => {\n                onMenuItemPointerMove(e);\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                onMenuItemPointerLeave(e);\n            }), addMeltEventListener(node, 'focusin', (e) => {\n                onItemFocusIn(e);\n            }), addMeltEventListener(node, 'focusout', (e) => {\n                onItemFocusOut(e);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const group = makeElement(name('group'), {\n        returned: () => {\n            return (groupId) => ({\n                role: 'group',\n                'aria-labelledby': groupId,\n            });\n        },\n    });\n    const groupLabel = makeElement(name('group-label'), {\n        returned: () => {\n            return (groupId) => ({\n                id: groupId,\n            });\n        },\n    });\n    const checkboxItemDefaults = {\n        defaultChecked: false,\n        disabled: false,\n    };\n    const createCheckboxItem = (props) => {\n        const withDefaults = { ...checkboxItemDefaults, ...props };\n        const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);\n        const checked = overridable(checkedWritable, withDefaults.onCheckedChange);\n        const disabled = writable(withDefaults.disabled);\n        const checkboxItem = makeElement(name('checkbox-item'), {\n            stores: [checked, disabled],\n            returned: ([$checked, $disabled]) => {\n                return {\n                    role: 'menuitemcheckbox',\n                    tabindex: -1,\n                    'data-orientation': 'vertical',\n                    'aria-checked': isIndeterminate($checked) ? 'mixed' : $checked ? 'true' : 'false',\n                    'data-disabled': disabledAttr($disabled),\n                    'data-state': getCheckedState($checked),\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                applyAttrsIfDisabled(node);\n                const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        e.preventDefault();\n                        return;\n                    }\n                }), addMeltEventListener(node, 'click', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        e.preventDefault();\n                        return;\n                    }\n                    if (e.defaultPrevented) {\n                        handleRovingFocus(itemEl);\n                        return;\n                    }\n                    checked.update((prev) => {\n                        if (isIndeterminate(prev))\n                            return true;\n                        return !prev;\n                    });\n                    if (closeOnItemClick.get()) {\n                        // We're waiting for a tick to let the checked store update\n                        // before closing the menu. If we don't, and the user was to hit\n                        // spacebar or enter twice really fast, the menu would close and\n                        // reopen without the checked state being updated.\n                        tick().then(() => {\n                            rootOpen.set(false);\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    onItemKeyDown(e);\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        onItemLeave(e);\n                        return;\n                    }\n                    onMenuItemPointerMove(e, itemEl);\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    onMenuItemPointerLeave(e);\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    onItemFocusOut(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        const isChecked = derived(checked, ($checked) => $checked === true);\n        const _isIndeterminate = derived(checked, ($checked) => $checked === 'indeterminate');\n        return {\n            elements: {\n                checkboxItem,\n            },\n            states: {\n                checked,\n            },\n            helpers: {\n                isChecked,\n                isIndeterminate: _isIndeterminate,\n            },\n            options: {\n                disabled,\n            },\n        };\n    };\n    const createMenuRadioGroup = (args = {}) => {\n        const valueWritable = args.value ?? writable(args.defaultValue ?? null);\n        const value = overridable(valueWritable, args.onValueChange);\n        const radioGroup = makeElement(name('radio-group'), {\n            returned: () => ({\n                role: 'group',\n            }),\n        });\n        const radioItemDefaults = {\n            disabled: false,\n        };\n        const radioItem = makeElement(name('radio-item'), {\n            stores: [value],\n            returned: ([$value]) => {\n                return (itemProps) => {\n                    const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };\n                    const checked = $value === itemValue;\n                    return {\n                        disabled,\n                        role: 'menuitemradio',\n                        'data-state': checked ? 'checked' : 'unchecked',\n                        'aria-checked': checked,\n                        'data-disabled': disabledAttr(disabled),\n                        'data-value': itemValue,\n                        'data-orientation': 'vertical',\n                        tabindex: -1,\n                    };\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        e.preventDefault();\n                        return;\n                    }\n                }), addMeltEventListener(node, 'click', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        e.preventDefault();\n                        return;\n                    }\n                    if (e.defaultPrevented) {\n                        if (!isHTMLElement(itemEl))\n                            return;\n                        handleRovingFocus(itemEl);\n                        return;\n                    }\n                    value.set(itemValue);\n                    if (closeOnItemClick.get()) {\n                        // We're waiting for a tick to let the checked store update\n                        // before closing the menu. If we don't, and the user was to hit\n                        // spacebar or enter twice really fast, the menu would close and\n                        // reopen without the checked state being updated.\n                        tick().then(() => {\n                            rootOpen.set(false);\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    onItemKeyDown(e);\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        onItemLeave(e);\n                        return;\n                    }\n                    onMenuItemPointerMove(e, itemEl);\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    onMenuItemPointerLeave(e);\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    onItemFocusOut(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        const isChecked = derived(value, ($value) => {\n            return (itemValue) => {\n                return $value === itemValue;\n            };\n        });\n        return {\n            elements: {\n                radioGroup,\n                radioItem,\n            },\n            states: {\n                value,\n            },\n            helpers: {\n                isChecked,\n            },\n        };\n    };\n    const { elements: { root: separator }, } = createSeparator({\n        orientation: 'horizontal',\n    });\n    /* -------------------------------------------------------------------------------------------------\n     * SUBMENU\n     * -----------------------------------------------------------------------------------------------*/\n    const subMenuDefaults = {\n        ...defaults,\n        disabled: false,\n        positioning: {\n            placement: 'right-start',\n            gutter: 8,\n        },\n    };\n    const createSubmenu = (args) => {\n        const withDefaults = { ...subMenuDefaults, ...args };\n        const subOpenWritable = withDefaults.open ?? writable(false);\n        const subOpen = overridable(subOpenWritable, withDefaults?.onOpenChange);\n        // options\n        const options = toWritableStores(omit(withDefaults, 'ids'));\n        const { positioning, arrowSize, disabled } = options;\n        const subActiveTrigger = withGet(writable(null));\n        const subOpenTimer = withGet(writable(null));\n        const pointerGraceTimer = withGet(writable(0));\n        const subIds = toWritableStores({ ...generateIds(menuIdParts), ...withDefaults.ids });\n        safeOnMount(() => {\n            /**\n             * Set active trigger on mount to handle controlled/forceVisible\n             * state.\n             */\n            const subTrigger = document.getElementById(subIds.trigger.get());\n            if (subTrigger) {\n                subActiveTrigger.set(subTrigger);\n            }\n        });\n        const subIsVisible = derivedVisible({\n            open: subOpen,\n            forceVisible,\n            activeTrigger: subActiveTrigger,\n        });\n        const subMenu = makeElement(name('submenu'), {\n            stores: [subIsVisible, subIds.menu, subIds.trigger],\n            returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {\n                return {\n                    role: 'menu',\n                    hidden: $subIsVisible ? undefined : true,\n                    style: styleToString({\n                        display: $subIsVisible ? undefined : 'none',\n                    }),\n                    id: $subMenuId,\n                    'aria-labelledby': $subTriggerId,\n                    'data-state': $subIsVisible ? 'open' : 'closed',\n                    // unit tests fail on `.closest` if the id starts with a number\n                    // so using a data attribute\n                    'data-id': $subMenuId,\n                    tabindex: -1,\n                };\n            },\n            action: (node) => {\n                let unsubPopper = noop;\n                const unsubDerived = effect([subIsVisible, positioning], ([$subIsVisible, $positioning]) => {\n                    unsubPopper();\n                    if (!$subIsVisible)\n                        return;\n                    const activeTrigger = subActiveTrigger.get();\n                    if (!activeTrigger)\n                        return;\n                    tick().then(() => {\n                        const parentMenuEl = getParentMenu(activeTrigger);\n                        const popper = usePopper(node, {\n                            anchorElement: activeTrigger,\n                            open: subOpen,\n                            options: {\n                                floating: $positioning,\n                                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : undefined,\n                                modal: null,\n                                focusTrap: null,\n                                escapeKeydown: null,\n                            },\n                        });\n                        if (popper && popper.destroy) {\n                            unsubPopper = popper.destroy;\n                        }\n                    });\n                });\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                    if (e.key === kbd.ESCAPE) {\n                        return;\n                    }\n                    // Submenu key events bubble through portals.\n                    // We only want the keys in this menu.\n                    const target = e.target;\n                    const menuEl = e.currentTarget;\n                    if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                        return;\n                    const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                    if (!isKeyDownInside)\n                        return;\n                    if (FIRST_LAST_KEYS.includes(e.key)) {\n                        // prevent events from bubbling\n                        e.stopImmediatePropagation();\n                        handleMenuNavigation(e, loop.get() ?? false);\n                        return;\n                    }\n                    const isCloseKey = SUB_CLOSE_KEYS['ltr'].includes(e.key);\n                    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                    const isCharacterKey = e.key.length === 1;\n                    // close the submenu if the user presses a close key\n                    if (isCloseKey) {\n                        const $subActiveTrigger = subActiveTrigger.get();\n                        e.preventDefault();\n                        subOpen.update(() => {\n                            if ($subActiveTrigger) {\n                                handleRovingFocus($subActiveTrigger);\n                            }\n                            return false;\n                        });\n                        return;\n                    }\n                    /**\n                     * Menus should not be navigated using tab, so we prevent it.\n                     * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                     */\n                    if (e.key === kbd.TAB) {\n                        e.preventDefault();\n                        rootOpen.set(false);\n                        handleTabNavigation(e, nextFocusable, prevFocusable);\n                        return;\n                    }\n                    if (!isModifierKey && isCharacterKey && typeahead.get() === true) {\n                        // typeahead logic\n                        handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                    }\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    onMenuPointerMove(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    const $subActiveTrigger = subActiveTrigger.get();\n                    if (isUsingKeyboard.get()) {\n                        const target = e.target;\n                        const submenuEl = document.getElementById(subIds.menu.get());\n                        if (!isHTMLElement(submenuEl) || !isHTMLElement(target))\n                            return;\n                        if (!submenuEl.contains(target) && target !== $subActiveTrigger) {\n                            subOpen.set(false);\n                        }\n                    }\n                    else {\n                        const menuEl = e.currentTarget;\n                        const relatedTarget = e.relatedTarget;\n                        if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))\n                            return;\n                        if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {\n                            subOpen.set(false);\n                        }\n                    }\n                }));\n                return {\n                    destroy() {\n                        unsubDerived();\n                        unsubPopper();\n                        unsubEvents();\n                    },\n                };\n            },\n        });\n        const subTrigger = makeElement(name('subtrigger'), {\n            stores: [subOpen, disabled, subIds.menu, subIds.trigger],\n            returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {\n                return {\n                    role: 'menuitem',\n                    id: $subTriggerId,\n                    tabindex: -1,\n                    'aria-controls': $subMenuId,\n                    'aria-expanded': $subOpen,\n                    'data-state': $subOpen ? 'open' : 'closed',\n                    'data-disabled': disabledAttr($disabled),\n                    'aria-haspopop': 'menu',\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                applyAttrsIfDisabled(node);\n                subActiveTrigger.update((p) => {\n                    if (p)\n                        return p;\n                    return node;\n                });\n                const unsubTimer = () => {\n                    clearTimerStore(subOpenTimer);\n                    window.clearTimeout(pointerGraceTimer.get());\n                    pointerGraceIntent.set(null);\n                };\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                    if (e.defaultPrevented)\n                        return;\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))\n                        return;\n                    // Manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n                    handleRovingFocus(triggerEl);\n                    if (!subOpen.get()) {\n                        subOpen.update((prev) => {\n                            const isAlreadyOpen = prev;\n                            if (!isAlreadyOpen) {\n                                subActiveTrigger.set(triggerEl);\n                                return !prev;\n                            }\n                            return prev;\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    const $typed = typed.get();\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))\n                        return;\n                    const isTypingAhead = $typed.length > 0;\n                    if (isTypingAhead && e.key === kbd.SPACE)\n                        return;\n                    if (SUB_OPEN_KEYS['ltr'].includes(e.key)) {\n                        if (!subOpen.get()) {\n                            triggerEl.click();\n                            e.preventDefault();\n                            return;\n                        }\n                        const menuId = triggerEl.getAttribute('aria-controls');\n                        if (!menuId)\n                            return;\n                        const menuEl = document.getElementById(menuId);\n                        if (!isHTMLElement(menuEl))\n                            return;\n                        const firstItem = getMenuItems(menuEl)[0];\n                        handleRovingFocus(firstItem);\n                    }\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    if (!isMouse(e))\n                        return;\n                    onItemEnter(e);\n                    if (e.defaultPrevented)\n                        return;\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    if (!isFocusWithinSubmenu(subIds.menu.get())) {\n                        handleRovingFocus(triggerEl);\n                    }\n                    const openTimer = subOpenTimer.get();\n                    if (!subOpen.get() && !openTimer && !isElementDisabled(triggerEl)) {\n                        subOpenTimer.set(window.setTimeout(() => {\n                            subOpen.update(() => {\n                                subActiveTrigger.set(triggerEl);\n                                return true;\n                            });\n                            clearTimerStore(subOpenTimer);\n                        }, 100));\n                    }\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    if (!isMouse(e))\n                        return;\n                    clearTimerStore(subOpenTimer);\n                    const submenuEl = document.getElementById(subIds.menu.get());\n                    const contentRect = submenuEl?.getBoundingClientRect();\n                    if (contentRect) {\n                        const side = submenuEl?.dataset.side;\n                        const rightSide = side === 'right';\n                        const bleed = rightSide ? -5 : +5;\n                        const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                        const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n                        pointerGraceIntent.set({\n                            area: [\n                                // Apply a bleed on clientX to ensure that our exit point is\n                                // consistently within polygon bounds\n                                { x: e.clientX + bleed, y: e.clientY },\n                                { x: contentNearEdge, y: contentRect.top },\n                                { x: contentFarEdge, y: contentRect.top },\n                                { x: contentFarEdge, y: contentRect.bottom },\n                                { x: contentNearEdge, y: contentRect.bottom },\n                            ],\n                            side,\n                        });\n                        window.clearTimeout(pointerGraceTimer.get());\n                        pointerGraceTimer.set(window.setTimeout(() => {\n                            pointerGraceIntent.set(null);\n                        }, 300));\n                    }\n                    else {\n                        onTriggerLeave(e);\n                        if (e.defaultPrevented)\n                            return;\n                        // There's 100ms where the user may leave an item before the submenu was opened.\n                        pointerGraceIntent.set(null);\n                    }\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    removeHighlight(triggerEl);\n                    const relatedTarget = e.relatedTarget;\n                    if (!isHTMLElement(relatedTarget))\n                        return;\n                    const menuId = triggerEl.getAttribute('aria-controls');\n                    if (!menuId)\n                        return;\n                    const menu = document.getElementById(menuId);\n                    if (menu && !menu.contains(relatedTarget)) {\n                        subOpen.set(false);\n                    }\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }));\n                return {\n                    destroy() {\n                        unsubTimer();\n                        unsubEvents();\n                    },\n                };\n            },\n        });\n        const subArrow = makeElement(name('subarrow'), {\n            stores: arrowSize,\n            returned: ($arrowSize) => ({\n                'data-arrow': true,\n                style: styleToString({\n                    position: 'absolute',\n                    width: `var(--arrow-size, ${$arrowSize}px)`,\n                    height: `var(--arrow-size, ${$arrowSize}px)`,\n                }),\n            }),\n        });\n        /* -------------------------------------------------------------------------------------------------\n         * Sub Menu Effects\n         * -----------------------------------------------------------------------------------------------*/\n        effect([rootOpen], ([$rootOpen]) => {\n            if (!$rootOpen) {\n                subActiveTrigger.set(null);\n                subOpen.set(false);\n            }\n        });\n        effect([pointerGraceIntent], ([$pointerGraceIntent]) => {\n            if (!isBrowser || $pointerGraceIntent)\n                return;\n            window.clearTimeout(pointerGraceTimer.get());\n        });\n        effect([subOpen], ([$subOpen]) => {\n            if (!isBrowser)\n                return;\n            if ($subOpen && isUsingKeyboard.get()) {\n                sleep(1).then(() => {\n                    const menuEl = document.getElementById(subIds.menu.get());\n                    if (!menuEl)\n                        return;\n                    const menuItems = getMenuItems(menuEl);\n                    if (!menuItems.length)\n                        return;\n                    handleRovingFocus(menuItems[0]);\n                });\n            }\n            if (!$subOpen) {\n                const focusedItem = currentFocusedItem.get();\n                const subTriggerEl = document.getElementById(subIds.trigger.get());\n                if (focusedItem) {\n                    sleep(1).then(() => {\n                        const menuEl = document.getElementById(subIds.menu.get());\n                        if (!menuEl)\n                            return;\n                        if (menuEl.contains(focusedItem)) {\n                            removeHighlight(focusedItem);\n                        }\n                    });\n                }\n                if (!subTriggerEl || document.activeElement === subTriggerEl)\n                    return;\n                removeHighlight(subTriggerEl);\n            }\n        });\n        return {\n            ids: subIds,\n            elements: {\n                subTrigger,\n                subMenu,\n                subArrow,\n            },\n            states: {\n                subOpen,\n            },\n            options,\n        };\n    };\n    safeOnMount(() => {\n        /**\n         * We need to set the active trigger on mount to cover the\n         * case where the user sets the `open` store to `true` without\n         * clicking on the trigger.\n         */\n        const triggerEl = document.getElementById(rootIds.trigger.get());\n        if (isHTMLElement(triggerEl) && rootOpen.get()) {\n            rootActiveTrigger.set(triggerEl);\n        }\n        const unsubs = [];\n        const handlePointer = () => isUsingKeyboard.set(false);\n        const handleKeyDown = () => {\n            isUsingKeyboard.set(true);\n            unsubs.push(executeCallbacks(addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true })));\n        };\n        const keydownListener = (e) => {\n            if (e.key === kbd.ESCAPE && closeOnEscape.get()) {\n                rootOpen.set(false);\n                return;\n            }\n        };\n        unsubs.push(addEventListener(document, 'keydown', handleKeyDown, { capture: true }));\n        unsubs.push(addEventListener(document, 'keydown', keydownListener));\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    /* -------------------------------------------------------------------------------------------------\n     * Root Effects\n     * -----------------------------------------------------------------------------------------------*/\n    effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {\n        if (!$rootOpen && $currentFocusedItem) {\n            removeHighlight($currentFocusedItem);\n        }\n    });\n    effect([rootOpen], ([$rootOpen]) => {\n        if (!isBrowser)\n            return;\n        if (!$rootOpen) {\n            const $rootActiveTrigger = rootActiveTrigger.get();\n            if (!$rootActiveTrigger)\n                return;\n            const $closeFocus = closeFocus.get();\n            if (!$rootOpen && $rootActiveTrigger) {\n                handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });\n            }\n        }\n    });\n    effect([rootOpen, preventScroll], ([$rootOpen, $preventScroll]) => {\n        if (!isBrowser)\n            return;\n        const unsubs = [];\n        if (opts.removeScroll && $rootOpen && $preventScroll) {\n            unsubs.push(removeScroll());\n        }\n        // if the menu is open, we'll sleep for a sec so the menu can render\n        // before we focus on either the first item or the menu itself.\n        sleep(1).then(() => {\n            const menuEl = document.getElementById(rootIds.menu.get());\n            if (menuEl && $rootOpen && isUsingKeyboard.get()) {\n                if (disableFocusFirstItem.get()) {\n                    handleRovingFocus(menuEl);\n                    return;\n                }\n                // Get menu items belonging to the root menu\n                const menuItems = getMenuItems(menuEl);\n                if (!menuItems.length)\n                    return;\n                // Focus on first menu item\n                handleRovingFocus(menuItems[0]);\n            }\n        });\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    effect(rootOpen, ($rootOpen) => {\n        if (!isBrowser)\n            return;\n        const handlePointer = () => isUsingKeyboard.set(false);\n        const handleKeyDown = (e) => {\n            isUsingKeyboard.set(true);\n            if (e.key === kbd.ESCAPE && $rootOpen && closeOnEscape.get()) {\n                rootOpen.set(false);\n                return;\n            }\n        };\n        return executeCallbacks(addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true }), addEventListener(document, 'keydown', handleKeyDown, { capture: true }));\n    });\n    function handleOpen(triggerEl) {\n        rootOpen.update((prev) => {\n            const isOpen = !prev;\n            if (isOpen) {\n                nextFocusable.set(getNextFocusable(triggerEl));\n                prevFocusable.set(getPreviousFocusable(triggerEl));\n                rootActiveTrigger.set(triggerEl);\n            }\n            return isOpen;\n        });\n    }\n    /* -------------------------------------------------------------------------------------------------\n     * Pointer Event Effects\n     * -----------------------------------------------------------------------------------------------*/\n    function onItemFocusIn(e) {\n        const itemEl = e.currentTarget;\n        if (!isHTMLElement(itemEl))\n            return;\n        const $currentFocusedItem = currentFocusedItem.get();\n        if ($currentFocusedItem) {\n            removeHighlight($currentFocusedItem);\n        }\n        addHighlight(itemEl);\n        /**\n         * Accomodates for Firefox focus event behavior, which differs\n         * from other browsers. We're setting the current focused item\n         * so when we close the menu, we can remove the data-highlighted\n         * attribute from the item, since a blur nor focusout event will be fired\n         * when the menu is closed via `clickOutside` or the ESC key.\n         */\n        currentFocusedItem.set(itemEl);\n    }\n    /**\n     * Each of the menu items share the same focusout event handler.\n     */\n    function onItemFocusOut(e) {\n        const itemEl = e.currentTarget;\n        if (!isHTMLElement(itemEl))\n            return;\n        removeHighlight(itemEl);\n    }\n    function onItemEnter(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            e.preventDefault();\n        }\n    }\n    function onItemLeave(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            return;\n        }\n        const target = e.target;\n        if (!isHTMLElement(target))\n            return;\n        const parentMenuEl = getParentMenu(target);\n        if (!parentMenuEl)\n            return;\n        handleRovingFocus(parentMenuEl);\n    }\n    function onTriggerLeave(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            e.preventDefault();\n        }\n    }\n    function onMenuPointerMove(e) {\n        if (!isMouse(e))\n            return;\n        const target = e.target;\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget) || !isHTMLElement(target))\n            return;\n        const $lastPointerX = lastPointerX.get();\n        const pointerXHasChanged = $lastPointerX !== e.clientX;\n        // We don't use `e.movementX` for this check because Safari will\n        // always return `0` on a pointer e.\n        if (currentTarget.contains(target) && pointerXHasChanged) {\n            const newDir = e.clientX > $lastPointerX ? 'right' : 'left';\n            pointerDir.set(newDir);\n            lastPointerX.set(e.clientX);\n        }\n    }\n    function onMenuItemPointerMove(e, currTarget = null) {\n        if (!isMouse(e))\n            return;\n        onItemEnter(e);\n        if (e.defaultPrevented)\n            return;\n        // if we've already checked the current target, we don't need to again\n        if (currTarget) {\n            handleRovingFocus(currTarget);\n            return;\n        }\n        // otherwise we will\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget))\n            return;\n        // focus on the current menu item\n        handleRovingFocus(currentTarget);\n    }\n    function onMenuItemPointerLeave(e) {\n        if (!isMouse(e))\n            return;\n        onItemLeave(e);\n    }\n    /* -------------------------------------------------------------------------------------------------\n     * Helper Functions\n     * -----------------------------------------------------------------------------------------------*/\n    function onItemKeyDown(e) {\n        const $typed = typed.get();\n        const isTypingAhead = $typed.length > 0;\n        if (isTypingAhead && e.key === kbd.SPACE) {\n            e.preventDefault();\n            return;\n        }\n        if (SELECTION_KEYS.includes(e.key)) {\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            e.preventDefault();\n            const itemEl = e.currentTarget;\n            if (!isHTMLElement(itemEl))\n                return;\n            itemEl.click();\n        }\n    }\n    function isIndeterminate(checked) {\n        return checked === 'indeterminate';\n    }\n    function getCheckedState(checked) {\n        return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n    }\n    function isPointerMovingToSubmenu(e) {\n        return pointerMovingToSubmenu.get()(e);\n    }\n    /**\n     * Get the parent menu element for a menu item.\n     * @param element The menu item element\n     */\n    function getParentMenu(element) {\n        const parentMenuEl = element.closest('[role=\"menu\"]');\n        if (!isHTMLElement(parentMenuEl))\n            return null;\n        return parentMenuEl;\n    }\n    return {\n        elements: {\n            trigger: rootTrigger,\n            menu: rootMenu,\n            overlay,\n            item,\n            group,\n            groupLabel,\n            arrow: rootArrow,\n            separator,\n        },\n        builders: {\n            createCheckboxItem,\n            createSubmenu,\n            createMenuRadioGroup,\n        },\n        states: {\n            open: rootOpen,\n        },\n        helpers: {\n            handleTypeaheadSearch,\n        },\n        ids: rootIds,\n        options: opts.rootOptions,\n    };\n}\nexport function handleTabNavigation(e, nextFocusable, prevFocusable) {\n    if (e.shiftKey) {\n        const $prevFocusable = prevFocusable.get();\n        if ($prevFocusable) {\n            e.preventDefault();\n            sleep(1).then(() => $prevFocusable.focus());\n            prevFocusable.set(null);\n        }\n    }\n    else {\n        const $nextFocusable = nextFocusable.get();\n        if ($nextFocusable) {\n            e.preventDefault();\n            sleep(1).then(() => $nextFocusable.focus());\n            nextFocusable.set(null);\n        }\n    }\n}\n/**\n * Get the menu items for a given menu element.\n * This only selects menu items that are direct children of the menu element,\n * not menu items that are nested in submenus.\n * @param element The menu item element\n */\nexport function getMenuItems(menuElement) {\n    return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id=\"${menuElement.id}\"]`)).filter((item) => isHTMLElement(item));\n}\nexport function applyAttrsIfDisabled(element) {\n    if (!element || !isElementDisabled(element))\n        return;\n    element.setAttribute('data-disabled', '');\n    element.setAttribute('aria-disabled', 'true');\n}\n/**\n * Given a timer store, clear the timeout and set the store to null\n * @param openTimer The timer store\n */\nexport function clearTimerStore(timerStore) {\n    if (!isBrowser)\n        return;\n    const timer = timerStore.get();\n    if (timer) {\n        window.clearTimeout(timer);\n        timerStore.set(null);\n    }\n}\n/**\n * Check if the event is a mouse event\n * @param e The pointer event\n */\nfunction isMouse(e) {\n    return e.pointerType === 'mouse';\n}\n/**\n * Set the `data-melt-menu-id` attribute on a menu item element.\n * @param element The menu item element\n */\nexport function setMeltMenuAttribute(element, selector) {\n    if (!element)\n        return;\n    const menuEl = element.closest(`${selector()}, ${selector('submenu')}`);\n    if (!isHTMLElement(menuEl))\n        return;\n    element.setAttribute('data-melt-menu-id', menuEl.id);\n}\n/**\n * Keyboard event handler for menu navigation\n * @param e The keyboard event\n */\nexport function handleMenuNavigation(e, loop) {\n    e.preventDefault();\n    // currently focused menu item\n    const currentFocusedItem = document.activeElement;\n    // menu element being navigated\n    const currentTarget = e.currentTarget;\n    if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))\n        return;\n    // menu items of the current menu\n    const menuItems = getMenuItems(currentTarget);\n    if (!menuItems.length)\n        return;\n    const candidateNodes = menuItems.filter((item) => {\n        if (item.hasAttribute('data-disabled') || item.getAttribute('disabled') === 'true') {\n            return false;\n        }\n        return true;\n    });\n    // Index of the currently focused item in the candidate nodes array\n    const currentIndex = candidateNodes.indexOf(currentFocusedItem);\n    // Calculate the index of the next menu item\n    let nextIndex;\n    switch (e.key) {\n        case kbd.ARROW_DOWN:\n            if (loop) {\n                nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;\n            }\n            else {\n                nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;\n            }\n            break;\n        case kbd.ARROW_UP:\n            if (loop) {\n                nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;\n            }\n            else {\n                nextIndex =\n                    currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;\n            }\n            break;\n        case kbd.HOME:\n            nextIndex = 0;\n            break;\n        case kbd.END:\n            nextIndex = candidateNodes.length - 1;\n            break;\n        default:\n            return;\n    }\n    handleRovingFocus(candidateNodes[nextIndex]);\n}\nfunction isPointerInGraceArea(e, area) {\n    if (!area)\n        return false;\n    const cursorPos = { x: e.clientX, y: e.clientY };\n    return isPointInPolygon(cursorPos, area);\n}\n/**\n * Determine if a point is inside of a polygon.\n *\n * @see https://github.com/substack/point-in-polygon\n */\nfunction isPointInPolygon(point, polygon) {\n    const { x, y } = point;\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i].x;\n        const yi = polygon[i].y;\n        const xj = polygon[j].x;\n        const yj = polygon[j].y;\n        // prettier-ignore\n        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect)\n            inside = !inside;\n    }\n    return inside;\n}\nfunction isFocusWithinSubmenu(submenuId) {\n    const activeEl = document.activeElement;\n    if (!isHTMLElement(activeEl))\n        return false;\n    // unit tests don't allow `.closest(#id)` to start with a number\n    // so we're using a data attribute.\n    const submenuEl = activeEl.closest(`[data-id=\"${submenuId}\"]`);\n    return isHTMLElement(submenuEl);\n}\nfunction stateAttr(open) {\n    return open ? 'open' : 'closed';\n}\n","import { overridable, toWritableStores } from '../../internal/helpers/index.js';\nimport { withGet } from '../../internal/helpers/withGet.js';\nimport { writable } from 'svelte/store';\nimport { omit } from '../../internal/helpers/object.js';\nimport { createMenuBuilder } from '../menu/index.js';\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    forceVisible: false,\n    typeahead: true,\n    closeFocus: undefined,\n    disableFocusFirstItem: false,\n    closeOnItemClick: true,\n    onOutsideClick: undefined,\n};\nexport function createDropdownMenu(props) {\n    const withDefaults = { ...defaults, ...props };\n    const rootOptions = toWritableStores(omit(withDefaults, 'ids'));\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);\n    const rootActiveTrigger = withGet(writable(null));\n    const nextFocusable = withGet(writable(null));\n    const prevFocusable = withGet(writable(null));\n    const { elements, builders, ids, states, options } = createMenuBuilder({\n        rootOptions,\n        rootOpen,\n        rootActiveTrigger: withGet(rootActiveTrigger),\n        nextFocusable: withGet(nextFocusable),\n        prevFocusable: withGet(prevFocusable),\n        selector: 'dropdown-menu',\n        removeScroll: true,\n        ids: withDefaults.ids,\n    });\n    return {\n        ids,\n        elements,\n        states,\n        builders,\n        options,\n    };\n}\n","import { makeElement, toWritableStores } from '../../internal/helpers/index.js';\nconst defaults = {\n    orientation: 'horizontal',\n    decorative: false,\n};\nexport const createSeparator = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { orientation, decorative } = options;\n    const root = makeElement('separator', {\n        stores: [orientation, decorative],\n        returned: ([$orientation, $decorative]) => {\n            const ariaOrientation = $orientation === 'vertical' ? $orientation : undefined;\n            return {\n                role: $decorative ? 'none' : 'separator',\n                'aria-orientation': ariaOrientation,\n                'aria-hidden': $decorative,\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n        options,\n    };\n};\n","export function getPositioningUpdater(store) {\n    return (props = {}) => {\n        return updatePositioning(store, props);\n    };\n}\nexport function updatePositioning(store, props) {\n    const defaultPositioningProps = {\n        side: \"bottom\",\n        align: \"center\",\n        sideOffset: 0,\n        alignOffset: 0,\n        sameWidth: false,\n        avoidCollisions: true,\n        collisionPadding: 8,\n        fitViewport: false,\n        strategy: \"absolute\",\n        overlap: false,\n    };\n    const withDefaults = { ...defaultPositioningProps, ...props };\n    store.update((prev) => {\n        return {\n            ...prev,\n            placement: joinPlacement(withDefaults.side, withDefaults.align),\n            offset: {\n                ...prev.offset,\n                mainAxis: withDefaults.sideOffset,\n                crossAxis: withDefaults.alignOffset,\n            },\n            gutter: 0,\n            sameWidth: withDefaults.sameWidth,\n            flip: withDefaults.avoidCollisions,\n            overflowPadding: withDefaults.collisionPadding,\n            boundary: withDefaults.collisionBoundary,\n            fitViewport: withDefaults.fitViewport,\n            strategy: withDefaults.strategy,\n            overlap: withDefaults.overlap,\n        };\n    });\n}\nfunction joinPlacement(side, align) {\n    if (align === \"center\")\n        return side;\n    return `${side}-${align}`;\n}\n","import { createBitAttrs, generateId, getOptionUpdater, removeUndefined, } from \"../../internal/index.js\";\nimport { createDropdownMenu, } from \"@melt-ui/svelte\";\nimport { getContext, setContext } from \"svelte\";\nimport { getPositioningUpdater } from \"../floating/helpers.js\";\nexport function getMenuData() {\n    const NAME = \"menu\";\n    const SUB_NAME = \"menu-submenu\";\n    const RADIO_GROUP_NAME = \"menu-radiogroup\";\n    const CHECKBOX_ITEM_NAME = \"menu-checkboxitem\";\n    const RADIO_ITEM_NAME = \"menu-radioitem\";\n    const GROUP_NAME = \"menu-group\";\n    const PARTS = [\n        \"arrow\",\n        \"checkbox-indicator\",\n        \"checkbox-item\",\n        \"content\",\n        \"group\",\n        \"item\",\n        \"label\",\n        \"radio-group\",\n        \"radio-item\",\n        \"radio-indicator\",\n        \"separator\",\n        \"sub-content\",\n        \"sub-trigger\",\n        \"trigger\",\n    ];\n    return {\n        NAME,\n        SUB_NAME,\n        RADIO_GROUP_NAME,\n        CHECKBOX_ITEM_NAME,\n        RADIO_ITEM_NAME,\n        GROUP_NAME,\n        PARTS,\n    };\n}\nexport function getCtx() {\n    const { NAME } = getMenuData();\n    return getContext(NAME);\n}\nexport function setCtx(props) {\n    const { NAME, PARTS } = getMenuData();\n    const getAttrs = createBitAttrs(\"menu\", PARTS);\n    const dropdownMenu = {\n        ...createDropdownMenu({ ...removeUndefined(props), forceVisible: true }),\n        getAttrs,\n    };\n    setContext(NAME, dropdownMenu);\n    return {\n        ...dropdownMenu,\n        updateOption: getOptionUpdater(dropdownMenu.options),\n    };\n}\nexport function setSubMenuCtx(props) {\n    const { SUB_NAME } = getMenuData();\n    const { builders: { createSubmenu }, getAttrs, } = getCtx();\n    const sub = { ...createSubmenu(removeUndefined(props)), getAttrs };\n    setContext(SUB_NAME, sub);\n    return {\n        ...sub,\n        updateOption: getOptionUpdater(sub.options),\n    };\n}\nexport function setRadioGroupCtx(props) {\n    const { RADIO_GROUP_NAME } = getMenuData();\n    const { builders: { createMenuRadioGroup }, getAttrs, } = getCtx();\n    const radioGroup = createMenuRadioGroup(props);\n    setContext(RADIO_GROUP_NAME, { ...radioGroup, getAttrs });\n    return {\n        ...radioGroup,\n        getAttrs,\n    };\n}\nexport function setRadioItem(value) {\n    const { RADIO_ITEM_NAME, RADIO_GROUP_NAME } = getMenuData();\n    const dropdownMenu = getContext(RADIO_GROUP_NAME);\n    setContext(RADIO_ITEM_NAME, { ...dropdownMenu, value });\n    return {\n        ...dropdownMenu,\n        value,\n    };\n}\nexport function getRadioIndicator() {\n    const { RADIO_ITEM_NAME } = getMenuData();\n    const radioItem = getContext(RADIO_ITEM_NAME);\n    return {\n        ...radioItem,\n    };\n}\nexport function getSubTrigger() {\n    const { SUB_NAME } = getMenuData();\n    const submenu = getContext(SUB_NAME);\n    return submenu;\n}\nexport function getSubmenuCtx() {\n    const { SUB_NAME } = getMenuData();\n    return getContext(SUB_NAME);\n}\nexport function setCheckboxItem(props) {\n    const { CHECKBOX_ITEM_NAME } = getMenuData();\n    const { builders: { createCheckboxItem }, getAttrs, } = getCtx();\n    const checkboxItem = createCheckboxItem(removeUndefined(props));\n    setContext(CHECKBOX_ITEM_NAME, checkboxItem.states.checked);\n    return {\n        ...checkboxItem,\n        updateOption: getOptionUpdater(checkboxItem.options),\n        getAttrs,\n    };\n}\nexport function getCheckboxIndicator() {\n    const { CHECKBOX_ITEM_NAME } = getMenuData();\n    return getContext(CHECKBOX_ITEM_NAME);\n}\nexport function setGroupCtx() {\n    const { GROUP_NAME } = getMenuData();\n    const { elements: { group }, getAttrs, } = getCtx();\n    const id = generateId();\n    setContext(GROUP_NAME, id);\n    return { group, id, getAttrs };\n}\nexport function getGroupLabel() {\n    const { GROUP_NAME } = getMenuData();\n    const id = getContext(GROUP_NAME) ?? generateId();\n    const { elements: { groupLabel }, getAttrs, } = getCtx();\n    return { groupLabel, id, getAttrs };\n}\nexport function setArrow(size = 8) {\n    const menu = getCtx();\n    menu.options.arrowSize.set(size);\n    return menu;\n}\nexport function updatePositioning(props) {\n    const defaultPlacement = {\n        side: \"bottom\",\n        align: \"center\",\n    };\n    const withDefaults = { ...defaultPlacement, ...props };\n    const { options: { positioning }, } = getCtx();\n    const updater = getPositioningUpdater(positioning);\n    updater(withDefaults);\n}\nexport function updateSubPositioning(props) {\n    const defaultSubPlacement = {\n        side: \"right\",\n        align: \"start\",\n    };\n    const withDefaults = { ...defaultSubPlacement, ...props };\n    const { options: { positioning }, } = getSubmenuCtx();\n    const updater = getPositioningUpdater(positioning);\n    updater(withDefaults);\n}\n","<script>import { setCtx } from \"../ctx.js\";\nimport { derived } from \"svelte/store\";\nexport let closeOnOutsideClick = void 0;\nexport let closeOnEscape = void 0;\nexport let portal = void 0;\nexport let open = void 0;\nexport let onOpenChange = void 0;\nexport let preventScroll = void 0;\nexport let loop = void 0;\nexport let dir = void 0;\nexport let typeahead = void 0;\nexport let closeFocus = void 0;\nexport let disableFocusFirstItem = void 0;\nexport let closeOnItemClick = void 0;\nexport let onOutsideClick = void 0;\nconst {\n  states: { open: localOpen },\n  updateOption,\n  ids\n} = setCtx({\n  closeOnOutsideClick,\n  closeOnEscape,\n  portal,\n  forceVisible: true,\n  defaultOpen: open,\n  preventScroll,\n  loop,\n  dir,\n  typeahead,\n  closeFocus,\n  disableFocusFirstItem,\n  closeOnItemClick,\n  onOutsideClick,\n  onOpenChange: ({ next }) => {\n    if (open !== next) {\n      onOpenChange?.(next);\n      open = next;\n    }\n    return next;\n  }\n});\nconst idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({\n  menu: $menuId,\n  trigger: $triggerId\n}));\n$:\n  open !== void 0 && localOpen.set(open);\n$:\n  updateOption(\"closeOnOutsideClick\", closeOnOutsideClick);\n$:\n  updateOption(\"closeOnEscape\", closeOnEscape);\n$:\n  updateOption(\"portal\", portal);\n$:\n  updateOption(\"preventScroll\", preventScroll);\n$:\n  updateOption(\"loop\", loop);\n$:\n  updateOption(\"dir\", dir);\n$:\n  updateOption(\"closeFocus\", closeFocus);\n$:\n  updateOption(\"disableFocusFirstItem\", disableFocusFirstItem);\n$:\n  updateOption(\"typeahead\", typeahead);\n$:\n  updateOption(\"closeOnItemClick\", closeOnItemClick);\n$:\n  updateOption(\"onOutsideClick\", onOutsideClick);\n</script>\n\n<slot ids={$idValues} />\n","<script>import { createDispatcher } from \"../../../internal/events.js\";\nimport { melt } from \"@melt-ui/svelte\";\nimport { getCtx, updatePositioning } from \"../ctx.js\";\nexport let transition = void 0;\nexport let transitionConfig = void 0;\nexport let inTransition = void 0;\nexport let inTransitionConfig = void 0;\nexport let outTransition = void 0;\nexport let outTransitionConfig = void 0;\nexport let asChild = false;\nexport let id = void 0;\nexport let side = \"bottom\";\nexport let align = \"center\";\nexport let sideOffset = 0;\nexport let alignOffset = 0;\nexport let collisionPadding = 8;\nexport let avoidCollisions = true;\nexport let collisionBoundary = void 0;\nexport let sameWidth = false;\nexport let fitViewport = false;\nexport let strategy = \"absolute\";\nexport let overlap = false;\nexport let el = void 0;\nconst {\n  elements: { menu },\n  states: { open },\n  ids,\n  getAttrs\n} = getCtx();\nconst dispatch = createDispatcher();\nconst attrs = getAttrs(\"content\");\n$:\n  if (id) {\n    ids.menu.set(id);\n  }\n$:\n  builder = $menu;\n$:\n  Object.assign(builder, attrs);\n$:\n  if ($open) {\n    updatePositioning({\n      side,\n      align,\n      sideOffset,\n      alignOffset,\n      collisionPadding,\n      avoidCollisions,\n      collisionBoundary,\n      sameWidth,\n      fitViewport,\n      strategy,\n      overlap\n    });\n  }\n</script>\n\n{#if asChild && $open}\n\t<slot {builder} />\n{:else if transition && $open}\n\t<div\n\t\tbind:this={el}\n\t\ttransition:transition={transitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if inTransition && outTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if inTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if outTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if $open}\n\t<div bind:this={el} {...builder} use:builder.action {...$$restProps} on:m-keydown={dispatch}>\n\t\t<slot {builder} />\n\t</div>\n{/if}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nimport { createDispatcher } from \"../../../internal/events.js\";\nexport let asChild = false;\nexport let id = void 0;\nexport let el = void 0;\nconst {\n  elements: { trigger },\n  ids,\n  getAttrs\n} = getCtx();\nconst dispatch = createDispatcher();\nconst attrs = getAttrs(\"trigger\");\n$:\n  if (id) {\n    ids.trigger.set(id);\n  }\n$:\n  builder = $trigger;\n$:\n  Object.assign(builder, attrs);\n</script>\n\n{#if asChild}\n\t<slot {builder} />\n{:else}\n\t<button\n\t\tbind:this={el}\n\t\t{...builder} use:builder.action\n\t\ttype=\"button\"\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t\ton:m-pointerdown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</button>\n{/if}\n"],"names":["last","array","wrapArray","startIndex","_","index","addHighlight","element","removeHighlight","sleep","ms","resolve","urlAlphabet","nanoid","size","id","i","generateId","generateIds","args","acc","curr","debounce","fn","wait","timeout","later","isDom","getPlatform","agent","pt","v","isTouchDevice","isMac","isApple","isIos","LOCK_CLASSNAME","assignStyle","el","style","previousStyle","setCSSProperty","property","value","previousValue","getPaddingProperty","documentElement","documentLeft","removeScroll","_document","doc","win","body","noop","scrollbarWidth","setScrollbarWidthProperty","paddingProperty","scrollbarSidePadding","setStyle","setIOSStyle","scrollX","scrollY","visualViewport","offsetLeft","offsetTop","restoreStyle","cleanups","derivedVisible","obj","open","forceVisible","activeTrigger","derived","$open","$forceVisible","$activeTrigger","handleRovingFocus","nextElement","isBrowser","currentFocusedElement","isHTMLElement","getFocusableElements","getNextFocusable","currentElement","focusableElements","nextIndex","getPreviousFocusable","previousIndex","prevElement","ignoredKeys","defaults","createTypeaheadSearch","withDefaults","typed","withGet","writable","resetTyped","key","items","currentItem","$typed","get","candidateItems","item","normalizeSearch","char","currentItemIndex","wrappedItems","nextItem","getPortalParent","node","parent","getPortalDestination","portalProp","handleFocus","prop","defaultEl","tick","returned","isFunction","min","max","round","floor","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","start","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","name","nextX","nextY","data","reset","detectOverflow","state","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","sides","_middlewareData$flip2","_overflowsData$filter","nextPlacement","resetPlacement","d","a","b","_overflowsData$filter2","currentSideAxis","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","getNodeName","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","result","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","scroll","offsets","isOffsetParentAnElement","offsetRect","getClientRects","getWindowScrollBarX","getDocumentRect","html","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","isStaticPositioned","getTrueOffsetParent","polyfill","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","observeMove","onMove","io","timeoutId","root","cleanup","_io","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","size$1","arrow$1","mergedOptions","platformWithCache","computePosition$1","defaultConfig","ARROW_TRANSFORM","useFloating","opts","arrowEl","arrowOffset","compute","align","getSideAndAlignFromPlacement","dir","candidateSelectors","candidateSelector","NoElement","matches","getRootNode","_element$getRootNode","isInert","lookUp","_node$getAttribute","inertAtt","inert","isContentEditable","_node$getAttribute2","attValue","getCandidates","includeContainer","filter","candidates","getCandidatesIteratively","elementsToCheck","assigned","content","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","hasTabIndex","getTabIndex","getSortOrderTabIndex","isScope","tabIndex","sortOrderedTabbables","isInput","isHiddenInput","isDetailsWithSummary","r","child","getCheckedRadio","nodes","form","isTabbableRadio","radioScope","queryRadios","radioSet","err","checked","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","isHidden","displayCheck","getShadowRoot","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","candidateTabindex","sortable","tabbable","container","focusable","isTabbable","focusableCandidateSelector","isFocusable","ownKeys","t","o","_objectSpread2","_defineProperty","_toPropertyKey","_toPrimitive","input","hint","prim","res","arg","activeFocusTraps","trapStack","trap","activeTrap","trapIndex","isSelectableInput","isEscapeEvent","e","isTabEvent","isKeyForward","isKeyBackward","delay","findIndex","arr","idx","valueOrHandler","_len","params","_key","getActualTarget","event","internalTrapStack","createFocusTrap","userOptions","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","composedPath","tabbableNodes","getNodeForOption","optionValue","_len2","_key2","getInitialFocusNode","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","focusableNodes","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","posTabIndexesFound","forward","nodeIdx","group","getActiveElement","activeElement","tryFocus","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2","target","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref3","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","checkFocusIn","targetContained","nextNode","navAcrossContainers","mruContainerIdx","mruTabIdx","g","n","checkKeyNav","checkKey","checkClick","addListeners","removeListeners","checkDomRemoval","mutations","isFocusedNodeRemoved","mutation","removedNodes","mutationObserver","updateObservedNodes","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","returnFocus","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","containerElements","elementsAsArray","immediate","focusTrapOptions","hasFocus","isPaused","activate","deactivate","pause","unpause","_createFocusTrap","_a","readonly","visibleModals","useModal","unsubInteractOutside","removeNodeFromVisibleModals","onClose","shouldCloseOnInteractOutside","closeOnInteractOutside","isLastModal","closeModal","onInteractOutsideStart","onInteractOutside","useInteractOutside","usePopper","popperElement","anchorElement","callbacks","portal","usePortal","useFocusTrap","usedFocusTrap","useEscapeKeydown","unsubscribe","executeCallbacks","targetEl","newTarget","destroy","unsub","isPointerDown","isPointerDownInside","ignoreEmulatedMouseEvents","enabled","onPointerDown","isValidEvent","isOrContainsTarget","triggerInteractOutside","documentObj","getOwnerDocument","onPointerUp","shouldTriggerInteractOutside","resetPointerState","addEventListener","onMouseUp","onTouchEnd","ownerDocument","SUB_OPEN_KEYS","SELECTION_KEYS","kbd","SUB_CLOSE_KEYS","menuIdParts","createMenuBuilder","createElHelpers","preventScroll","arrowSize","positioning","closeOnEscape","closeOnOutsideClick","typeahead","loop","closeFocus","disableFocusFirstItem","closeOnItemClick","onOutsideClick","rootOpen","rootActiveTrigger","nextFocusable","prevFocusable","isUsingKeyboard","lastPointerX","pointerGraceIntent","pointerDir","currentFocusedItem","pointerMovingToSubmenu","$pointerDir","$pointerGraceIntent","isPointerInGraceArea","handleTypeaheadSearch","rootIds","toWritableStores","isVisible","rootMenu","makeElement","$isVisible","$portal","$rootMenuId","$rootTriggerId","styleToString","portalAttr","unsubPopper","unsubDerived","effect","$rootActiveTrigger","$positioning","$closeOnOutsideClick","$closeOnEscape","setMeltMenuAttribute","popper","unsubEvents","addMeltEventListener","menuEl","FIRST_LAST_KEYS","handleMenuNavigation","handleTabNavigation","isCharacterKey","getMenuItems","rootTrigger","$rootOpen","applyAttrsIfDisabled","p","triggerEl","handleOpen","menuId","menu","menuItems","rootArrow","$arrowSize","overlay","stateAttr","unsubEscapeKeydown","escapeKeydown","unsubPortal","portalDestination","portalAction","itemEl","isElementDisabled","onItemKeyDown","onMenuItemPointerMove","onMenuItemPointerLeave","onItemFocusIn","onItemFocusOut","groupId","groupLabel","checkboxItemDefaults","createCheckboxItem","props","checkedWritable","overridable","disabled","checkboxItem","$checked","$disabled","isIndeterminate","disabledAttr","getCheckedState","prev","onItemLeave","isChecked","_isIndeterminate","createMenuRadioGroup","valueWritable","radioGroup","radioItemDefaults","radioItem","$value","itemProps","itemValue","separator","createSeparator","subMenuDefaults","createSubmenu","subOpenWritable","subOpen","omit","subActiveTrigger","subOpenTimer","pointerGraceTimer","subIds","safeOnMount","subTrigger","subIsVisible","subMenu","$subIsVisible","$subMenuId","$subTriggerId","parentMenuEl","getParentMenu","isCloseKey","isModifierKey","$subActiveTrigger","onMenuPointerMove","submenuEl","relatedTarget","$subOpen","unsubTimer","clearTimerStore","firstItem","isMouse","onItemEnter","isFocusWithinSubmenu","openTimer","contentRect","rightSide","bleed","contentNearEdge","contentFarEdge","onTriggerLeave","subArrow","focusedItem","subTriggerEl","unsubs","handlePointer","handleKeyDown","keydownListener","$currentFocusedItem","$closeFocus","$preventScroll","isOpen","isPointerMovingToSubmenu","currentTarget","$lastPointerX","pointerXHasChanged","newDir","currTarget","$prevFocusable","$nextFocusable","menuElement","timerStore","timer","candidateNodes","currentIndex","area","cursorPos","isPointInPolygon","point","polygon","inside","j","xi","yi","xj","yj","submenuId","activeEl","createDropdownMenu","rootOptions","openWritable","builders","ids","states","orientation","decorative","$orientation","$decorative","getPositioningUpdater","store","updatePositioning","joinPlacement","getMenuData","getCtx","NAME","getContext","setCtx","PARTS","getAttrs","createBitAttrs","dropdownMenu","removeUndefined","setContext","getOptionUpdater","setSubMenuCtx","SUB_NAME","sub","getSubTrigger","getSubmenuCtx","updateSubPositioning","ctx","$$props","onOpenChange","localOpen","updateOption","next","$$invalidate","idValues","$menuId","$triggerId","div_levels","insert_hydration","div","anchor","transition","transitionConfig","inTransition","inTransitionConfig","outTransition","outTransitionConfig","asChild","sideOffset","alignOffset","collisionPadding","avoidCollisions","collisionBoundary","sameWidth","fitViewport","overlap","dispatch","createDispatcher","attrs","$$value","builder","$menu","button_levels","button","trigger","$trigger"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]}